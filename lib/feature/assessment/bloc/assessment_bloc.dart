// feature/assessment/presentation/bloc/assessment_bloc.dart
import 'dart:async';
import 'package:bloc/bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:quiz/feature/assessment/data/helper/questions_en.dart';
import 'package:quiz/feature/assessment/data/helper/questions_ar.dart';
import 'package:quiz/feature/assessment/data/models/analysis_result/analysis_result.dart';
// Import OrganicResult/SearchResult
import 'package:quiz/feature/assessment/data/models/jop_search/search_model.dart';
import 'package:quiz/feature/assessment/data/models/assessment_question/assessment_question.dart';
import 'package:quiz/feature/assessment/data/repositories/assessment_repository.dart';
import 'package:quiz/core/utils/di.dart';
import 'package:quiz/core/local_settings/local_settings_bloc.dart';
import 'package:flutter_easyloading/flutter_easyloading.dart';
import 'package:quiz/feature/assessment/data/repositories/search_repositories.dart';
import 'package:quiz/feature/assessment/data/service/firestore_service.dart';

part 'assessment_event.dart';
part 'assessment_state.dart';
part 'assessment_bloc.freezed.dart'; // Generated by Freezed

class AssessmentBloc extends Bloc<AssessmentEvent, AssessmentState> {
  final AssessmentRepository repository;
  final FirestoreService _firestoreService;
  final LocalSettingsBloc _localSettingsBloc;
  final SearchRepository _searchRepository; // Add SearchRepository instance
  final List<Map<String, dynamic>> messages = [];
  final Map<String, String> answers = {};
  List<AssessmentQuestion> levelQuestions = [];
  String? selectedLevel;
  int currentQuestionIndex = 0;
  bool analysisComplete = false;

  AssessmentBloc(this.repository)
      : _firestoreService = getIt<FirestoreService>(),
        _localSettingsBloc = getIt<LocalSettingsBloc>(),
        _searchRepository = SearchRepository(), // Initialize SearchRepository
        super(const AssessmentState.initial()) {
    on<AssessmentEvent>((event, emit) async {
      await event.when(
        started: (level) => _onAssessmentStarted(level, emit),
        answerSubmitted: (questionId, answer) =>
            _onAnswerSubmitted(questionId, answer, emit),
        prevQuestion: () => _onPrevQuestion(emit),
        analysisRequested: () => _onAnalysisRequested(emit),
        analysisComplete: (result) => _onAnalysisComplete(result, emit),
        reset: () => _onResetAssessment(emit),
        saveResult: (result) => _onSaveResult(result, emit),
      );
    });
  }

  // Helper method to get the current locale from LocalSettingsBloc
  String get _currentLocale {
    try {
      return _localSettingsBloc.state.local;
    } catch (e) {
      return 'en'; // Fallback to English
    }
  }

  // Helper method to get the right question set based on locale
  List<AssessmentQuestion> get _questions {
    return _currentLocale == 'ar' ? questionsAr : questionsEn;
  }

  double get progress {
    final total = levelQuestions.fold<int>(0, (s, q) => s + q.weight);
    final answered = levelQuestions
        .where((q) => answers.containsKey(q.id))
        .fold<int>(0, (s, q) => s + q.weight);
    if (total == 0) return 0.0;
    return answered / total;
  }

  void _addBot(String content, {bool isLoading = false}) {
    messages.add({
      'sender': 'bot',
      'content': content,
      'timestamp': DateTime.now().toIso8601String(),
      'isLoading': isLoading,
    });
  }

  void _addUser(String content) {
    messages.add({
      'sender': 'user',
      'content': content,
      'timestamp': DateTime.now().toIso8601String(),
      'isLoading': false,
    });
  }

  FutureOr<void> _onAssessmentStarted(
      String? level, Emitter<AssessmentState> emit) {
    selectedLevel = level ?? 'Level 1';
    // Use the appropriate question set based on locale
    final questions = _questions;
    // Filter questions by selected level
    switch (selectedLevel) {
      case 'Level 1':
        // Q1 to Q20
        levelQuestions = questions
            .where((q) {
              final idNumber = int.tryParse(
                q.id.replaceAll(RegExp(r'[^0-9]'), ''),
              );
              return idNumber != null && idNumber >= 1 && idNumber <= 20;
            })
            .toList();
        break;
      case 'Level 2':
        // Q1 to Q60
        levelQuestions = questions
            .where((q) {
              final idNumber = int.tryParse(
                q.id.replaceAll(RegExp(r'[^0-9]'), ''),
              );
              return idNumber != null && idNumber >= 1 && idNumber <= 60;
            })
            .toList();
        break;
      case 'Level 3':
        // All questions
        levelQuestions = List.from(questions);
        break;
      default:
        levelQuestions = questions
            .where((q) {
              final idNumber = int.tryParse(
                q.id.replaceAll(RegExp(r'[^0-9]'), ''),
              );
              return idNumber != null && idNumber >= 1 && idNumber <= 20;
            })
            .toList();
    }
    messages.clear();
    answers.clear();
    currentQuestionIndex = 0;
    analysisComplete = false;
    _addBot(
      "Starting $selectedLevel assessment. ${levelQuestions.length} questions.",
    );
    if (levelQuestions.isNotEmpty) {
      final q = levelQuestions[currentQuestionIndex];
      _addBot(
          "[${q.level}] ${q.text} (Estimated: ${q.timeSeconds} seconds)");
      emit(
        AssessmentState.loaded(
          messages: List.from(messages),
          currentQuestion: q,
          progress: progress,
          currentIndex: currentQuestionIndex,
        ),
      );
    } else {
      emit(
        AssessmentState.loaded(
          messages: List.from(messages),
          currentQuestion: null,
          progress: 0.0,
          currentIndex: 0,
        ),
      );
    }
  }

  FutureOr<void> _onAnswerSubmitted(
    String questionId,
    String answer,
    Emitter<AssessmentState> emit,
  ) async {
    if (analysisComplete) {
      _addBot("Analysis is already complete. Answers cannot be modified.");
      emit(
        AssessmentState.loaded(
          messages: List.from(messages),
          currentQuestion: null,
          progress: progress,
          currentIndex: currentQuestionIndex,
        ),
      );
      return;
    }
    final idx = currentQuestionIndex;
    if (idx < 0 || idx >= levelQuestions.length) return;
    final currentQ = levelQuestions[idx];
    answers[currentQ.id] = answer;
    _addUser(answer);
    if (messages.isNotEmpty && messages.last['isLoading'] == true) {
      messages.removeLast();
    }
    currentQuestionIndex++;
    if (currentQuestionIndex < levelQuestions.length) {
      final next = levelQuestions[currentQuestionIndex];
      _addBot(
          "[${next.level}] ${next.text} (Estimated: ${next.timeSeconds} seconds)");
      emit(
        AssessmentState.loaded(
          messages: List.from(messages),
          currentQuestion: next,
          progress: progress,
          currentIndex: currentQuestionIndex,
        ),
      );
    } else {
      add(const AssessmentEvent.analysisRequested());
    }
  }

  FutureOr<void> _onPrevQuestion(Emitter<AssessmentState> emit) {
    if (analysisComplete) {
      _addBot("Analysis is already complete. You cannot go back.");
      emit(
        AssessmentState.loaded(
          messages: List.from(messages),
          currentQuestion: null,
          progress: progress,
          currentIndex: currentQuestionIndex,
        ),
      );
      return null; // Corrected return type
    }
    if (currentQuestionIndex > 0) {
      currentQuestionIndex--;
      final q = levelQuestions[currentQuestionIndex];
      _addBot("Returning to the previous question: [${q.level}] ${q.text}");
      emit(
        AssessmentState.loaded(
          messages: List.from(messages),
          currentQuestion: q,
          progress: progress,
          currentIndex: currentQuestionIndex,
        ),
      );
    } else {
      _addBot("You are already at the first question.");
      emit(
        AssessmentState.loaded(
          messages: List.from(messages),
          currentQuestion: levelQuestions.isNotEmpty ? levelQuestions.first : null,
          progress: progress,
          currentIndex: currentQuestionIndex,
        ),
      );
    }
  }

  Future<void> _onAnalysisRequested(Emitter<AssessmentState> emit) async {
    EasyLoading.show(status: 'Analyzing responses...');
    _addBot("Analyzing responses...", isLoading: true);
    emit(
      AssessmentState.loaded(
        messages: List.from(messages),
        currentQuestion: null,
        progress: progress,
        currentIndex: currentQuestionIndex,
      ),
    );
    try {
      final payload = levelQuestions
          .map(
            (q) => {
              'id': q.id,
              'level': q.level,
              'question': q.text,
              'answer': answers[q.id] ?? '',
              'weight': q.weight,
            },
          )
          .toList();
      final result = await repository.analyzeResponses(payload);
      analysisComplete = true;
      await EasyLoading.dismiss();
      // Pass the AI result for further processing
      add(AssessmentEvent.analysisComplete(result));
    } catch (e) {
      await EasyLoading.dismiss();
      if (messages.isNotEmpty && messages.last['isLoading'] == true) {
        messages.removeLast();
      }
      _addBot("Analysis failed: ${e.toString()}");
      emit(AssessmentState.error(e.toString()));
    }
  }

  FutureOr<void> _onAnalysisComplete(
    AnalysisResult result, // This is the initial result from AI
    Emitter<AssessmentState> emit,
  ) async {
    if (messages.isNotEmpty && messages.last['isLoading'] == true) {
      messages.removeLast();
    }

    // --- NEW LOGIC: Search and Update Result ---
    String? searchQuery;
    // Start with a copy of the existing AI-provided learning resources
    List<Map<String, dynamic>> updatedLearningResources =
        List.from(result.learningResources);

    // 1. Extract the first freelance job for the search query
    final freelanceJobsList = result.freelanceJobs['uiList'] as List?;
    if (freelanceJobsList != null && freelanceJobsList.isNotEmpty) {
      final firstJob = freelanceJobsList.first.toString().trim();
      if (firstJob.isNotEmpty) {
        // Refine the query for better search results
        searchQuery =
            "best free online courses or tutorials for $firstJob freelance skills";
        // Consider language context if needed: searchQuery = "أفضل دورات مجانية لـ $firstJob العمل الحر";
      }
    }

    // Fallback if no job found in uiList or extraction failed
    if (searchQuery == null || searchQuery.isEmpty) {
      final freelanceJobsWordList = result.freelanceJobs['wordList'] as List?;
      if (freelanceJobsWordList != null && freelanceJobsWordList.isNotEmpty) {
        final firstJobDescription =
            freelanceJobsWordList.first.toString().split(' - ').firstOrNull ??
                "";
        if (firstJobDescription.trim().isNotEmpty) {
          searchQuery =
              "best free online courses or tutorials for $firstJobDescription freelance skills";
        }
      }
    }

    // Final generic fallback
    if (searchQuery == null || searchQuery.isEmpty) {
      searchQuery = "freelance skills for beginners"; // Generic fallback
    }

    // 2. Perform the search if a query was constructed
    if (searchQuery.isNotEmpty) {
      try {
        _addBot(
            "Searching for additional learning resources related to: $searchQuery...");
        // Update UI state to show loading for search
        emit(
          AssessmentState.loaded(
            messages: List.from(messages),
            currentQuestion: null,
            progress: progress,
            currentIndex: currentQuestionIndex,
          ),
        );

        final searchResultsEither =
            await _searchRepository.searchQuery(searchQuery);

        await searchResultsEither.fold(
          (error) async {
            // Handle search error
            _addBot("Could not fetch additional resources via search: $error");
            print("Search Error in Bloc: $error");
            // Continue with original resources
          },
          (organicResults) async {
            // 3. Process search results into the required format
            final List<Map<String, dynamic>> searchResultResources =
                organicResults.map((organicResult) {
              // Map OrganicResult fields to AnalysisResult.learningResources format
              return {
                'name': organicResult.title,
                'type': 'Course/Playlist/YouTube/Guide',
                'url': organicResult.link,
                'description':
                    'Resource found via search for: $searchQuery',
                'lastUpdated': null, // Serper results might not have this easily
              };
            }).toList();

            // 4. Merge the new search results with the existing AI resources
            // Option 1: Append (Recommended to avoid losing AI's specific links)
            if (searchResultResources.isNotEmpty) {
              updatedLearningResources.addAll(searchResultResources);
              _addBot(
                  "Found ${searchResultResources.length} additional learning resources and appended them.");
              print(
                  "Appended ${searchResultResources.length} search results to learning resources.");
            } else {
              _addBot(
                  "Search completed, but no additional resources were found.");
              print("Search returned no results.");
            }

            // Option 2 (Alternative - less preferred based on prompt):
            // Replace AI results with search results (if you specifically want ONLY search results)
            // This would lose the AI-provided links if they were good.
            // updatedLearningResources = searchResultResources;
            // _addBot("Replaced AI learning resources with ${searchResultResources.length} found resources (if any).");
          },
        );
      } catch (searchError, stackTrace) {
        // Handle unexpected errors during search
        _addBot("An unexpected error occurred during the search.");
        print(
            "Unexpected Search Error in Bloc: $searchError\nStack Trace: $stackTrace");
        // Continue with original resources
      }
    } else {
      _addBot(
          "No specific freelance job found to search for learning resources.");
      print("Search query was empty.");
    }

    // 5. Create an *updated* AnalysisResult with the new/combined learning resources
    // This relies on the `copyWith` method being generated by Freezed for AnalysisResult.
    // Ensure you run `flutter pub run build_runner build --delete-conflicting-outputs`.
    final AnalysisResult updatedResult = result.copyWith(
      learningResources:
          updatedLearningResources, // Use the updated list
    );
    print(
        "Original result.learningResources length: ${result.learningResources.length}");
    print(
        "Updated result.learningResources length: ${updatedResult.learningResources.length}");
    // Optional check (might not work reliably due to object copying)
    // print("Original and Updated result are identical objects: ${identical(result, updatedResult)}");

    // 6. Add event to save the *updated* result
    add(AssessmentEvent.saveResult(
        updatedResult)); // Pass the updated result

    // 7. Display the result's UI summary (using the updated result for consistency in display)
    final formatted = '''
${updatedResult.uiSummary}
Personality:
${updatedResult.personalityType}
Learning Style:
- Visual: ${updatedResult.learningStylePercentages['Visual']}%
- Verbal: ${updatedResult.learningStylePercentages['Verbal']}%
- Kinesthetic: ${updatedResult.learningStylePercentages['Kinesthetic']}%
Goals:
${updatedResult.inferredGoals.map((g) => '- $g').join('\n')}
Strengths:
${updatedResult.keyStrengths.map((s) => '- $s').join('\n')}
Development Areas:
${updatedResult.developmentAreas.map((d) => '- $d').join('\n')}
Career Suggestions:
${updatedResult.careerSuggestions.map((c) => '- $c').join('\n')}
Learning Resources: // Display the *updated* resources in the chat
${updatedResult.learningResources.map((r) {
      // Use updated resources for display
      final name = r['name'] ?? '';
      final description = r['description'] ?? '';
      final url = r['url'] ?? '';
      // Include link in chat display for clarity
      return '- $name: $description (Link: $url)';
    }).join('\n')}
''';

    _addBot(formatted);
    emit(
      AssessmentState.analysisComplete(
        result: updatedResult, // Emit the updated result state
        messages: List.from(messages),
      ),
    );
  }

  FutureOr<void> _onSaveResult(
    AnalysisResult result, // This is now the updated result
    Emitter<AssessmentState> emit,
  ) async {
    try {
      print(
          "Saving result with ${result.learningResources.length} learning resources.");
      await _firestoreService.saveAnalysisResult(
        result: result, // Save the updated result with new learning resources
        assessmentLevel: selectedLevel ?? 'Unknown',
      );
      _addBot("Result and learning resources saved successfully!");
      print("Result saved successfully to Firestore.");
    } catch (e, stackTrace) {
      _addBot("Failed to save result: $e");
      print('Error saving result to Firestore: $e\nStack Trace: $stackTrace');
    }
  }

  FutureOr<void> _onResetAssessment(Emitter<AssessmentState> emit) {
    messages.clear();
    answers.clear();
    levelQuestions.clear();
    currentQuestionIndex = 0;
    analysisComplete = false;
    selectedLevel = null;
    emit(const AssessmentState.initial());
  }

  // Placeholder methods for search events if you decide to use them later for manual searches
  /*
  FutureOr<void> _onSearchRequested(
    String query,
    Emitter<AssessmentState> emit,
  ) async {
    // Could be used for a manual search feature
    emit(const AssessmentState.searchLoading());
    try {
      final resultsEither = await _searchRepository.searchQuery(query);
      resultsEither.fold(
        (error) => add(const AssessmentEvent.searchCompleted([])), // Or emit an error state
        (results) => add(AssessmentEvent.searchCompleted(results)),
      );
    } catch (e) {
       emit(AssessmentState.searchError(e.toString()));
    }
  }

  FutureOr<void> _onSearchCompleted(
    List<OrganicResult> results,
    Emitter<AssessmentState> emit,
  ) {
     emit(AssessmentState.searchSuccess(results));
     // Handle displaying manual search results
  }
  */
}
